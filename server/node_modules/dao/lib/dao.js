var path = require('path')
  , util = require('util')
  , events = require('events')
  , utils = require('./utils');

/**
 *
 */
var App = exports.App = function(options) {
  if (!(this instanceof App)) {
    return new App(options);
  }

  options = typeof options == "object" ? options : {};

  this.options = options;
  this.root = options.root || path.dirname(require.main.filename);
  this.env = options.env || process.env['NODE_ENV'] || 'development';


  events.EventEmitter.call(this);

  this.plugins = {};
  this.initialized = true;
  this.initList = [];

  return this;
};

util.inherits(App, events.EventEmitter);

/**
 *
 */
App.prototype.use = function(plugin, options) {
  var name = plugin.name || utils.uniqueId();

  options = options || {};

  if (this.plugins[name]) {
    throw new Error('Plugin with name "%s" is used already');
  }

  this.plugins[name] = plugin;
  this.options[name] = options = utils.extend({}, this.options[name] || {}, options);

  if (plugin.attach) {
    plugin.attach.call(this, options);
  }

  if (plugin.deps && typeof plugin.deps == 'string') {
    plugin.deps = typeof plugin.deps == 'string' 
                ? plugin.deps.replace(/ +/g, '', 'm').split(',')
                : plugin.deps;
  }

  if (plugin.init) {
    this.initialized = false;
    this.initList.push(name);
  }

  return this;
};

/**
 *
 */
App.prototype.initSequentially = function(callback) {
  var app = this
    , initList = this.initList;

  if (!this.checkDeps()) {
    return callback(new Error('Unresolved dependency'));
  }

  // 
  (function initNext(err) {
    if (err) {
      return callback(err);
    }

    if (!initList.length) {
      app.initialized = true;
      return callback(null);
    }

    app.plugins[initList.shift()].init.call(app, initNext);
  })();
};

/**
 *
 */
App.prototype.init = function(callback) {
  if (!this.checkDeps()) {
    return callback(new Error('Unresolved dependency'));
  }

  var plugins = this.plugins
    , app = this, name
    , initiated = {}
    , inProgress = [];

  this.initList.forEach(function(el) {
    initiated[el] = false;
  });

  // Возвращает true, когда все плагины инициализированы
  var isAppInitiated = function() {
    for (name in initiated) {
      if (!initiated[name]) {
        return false;
      }
    }
    return true;
  };

  // true, если плагин инициализируется в данный момент
  var isInProgress = function(name) {
    return !!(~ inProgress.indexOf(name));
  };
  
  // Возвращает список имён неинициализированных плагинов, готовых к инициализации,
  // но не инициализируемых в данный момент
  var readyToInit = function() {
    var list = [], plugin, dep, d, ready;

    for (var name in app.initList) {
      name = app.initList[name];
      if (!initiated[name] && !isInProgress(name)) {
        plugin = plugins[name];
        if (!plugin.deps) {
          list.push(name);
          continue;
        }

        ready = true;
        for (d in plugin.deps) {
          dep = plugin.deps[d];
          if (!initiated[dep]) {
            ready = false;
            break;
          }
        }

        if (ready) {
          list.push(name);
        }
      }
    }

    return list;
  };

  // Производит инициализацию плагина с заданным именем
  var noCallback = function() { throw new Error('Plugin was already initiated once') }
  var initPlugin = function(name, cb) {
    inProgress.push(name);
    plugins[name].init.call(app, function(err){
      if (err) { return cb(err); }

      inProgress.splice(inProgress.indexOf(name), 1);
      initiated[name] = true;
      cb();
      cb = noCallback;
    });
  };

  // Запускает инициализацию всех плагинов, зависимости которых уже инициализированы
  var initAvailable = function initAvailable(err) {
    if (err) { return callback(err); }

    var toInit = readyToInit();

    if (isAppInitiated()) {
      app.initialized = true;
      return callback();                // all plugins has been initiated
    }

    // Application is not yet initiated, but we are already doing nothing
    // TODO: Remove this lines after app.checkDeps() will be able to spot this situation
    if (toInit.length === 0 && inProgress.length == 0 ) {
      callback(new Error('Unresolved dependency'));
    }

    // Запускаем инициализацию всех доступных плагинов
    toInit.forEach(function(name) {
      initPlugin(name, initAvailable);
    });
  };

  initAvailable();
};

/** 
 *   Checks plugins for missing dependepcies. 
 *      Nb!: Dirty check. Doesn't spot dependency loops 
 */
App.prototype.checkDeps = function() {
  var plugin, dep, deps
    , plugins = this.plugins
    , depsList = [];

  for (plugin in plugins) {
    if (plugins[plugin].deps) {
      for (dep in deps = plugins[plugin].deps) {
        if (depsList.indexOf(deps[dep]) == -1) {
          depsList.push(deps[dep]);
        }
      }
    }
  }

  for (dep in depsList) {
    if (!plugins[depsList[dep]]) {
      //console.log('Plugin ' + depsList[dep] + ' is missing');
      return false;
    }
  }

  return true;
};